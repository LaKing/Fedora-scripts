#!/bin/bash
# Last update:2014.04.24-03:30:19
# version 1.8.3
#
# Server Controll script for Fedora with LXC containers
#
# D250 Laboratories / D250.hu
# Author: István király
# LaKing@D250.hu
# 
## Source URL
#URL="http://d250.hu/scripts/install-workstation.sh"

## If user is root or runs on root privileges, continiue.
if [ "$UID" -ne "0" ]
then
  echo "Root privileges needed to run this script."
  ## Attemt to get root privileges with sudo, and run the script
  ## sudo bash $0 $1 $2 $3 $4 $5 $6 $7 $8 $9
  exit
fi

## check for arguments
if [ -z "$1" ]
  then
    echo "srvctl command [argument]"
    ## TODO a more detailed manual. .)
fi




## Configuration defaults - Overwrite in config!
MSG="## srvctl modification. $NOW"

## logfile
LOG=/var/log/srvctl.log

## temporal backup and work directory
TMP=/temp

## The main /srv folder
SRV=/srv

## Used for certificate generation
ssl_password="no_pass"

## Company codename
CMP="D250 laboratories"

## Company domain name
CDN="d250.hu"

## IPv4 Address
HOSTIPv4=$(dig +time=1 +short $(hostname))

## Import custom configuration directives
source /etc/srvctl/config 2> /dev/null

## Some way to figure out, .. is this script running in the srvctl container, or on the host system?
if mount | grep -q 'on /var/srvctl' 
then
  ## We are in a container of srvctl for sure
  #echo CONTAINER $(hostname)
  onHS=false
  onVE=true
else
  ## We are propably on the host
  #echo HOST $(hostname)
  onHS=true
  onVE=false
fi

## some date
NOW=$(date +%Y.%m.%d-%H:%M:%S)

CMD=$1
ARG=$2

## Lablib functions

## constants

green='\e[32m'
red='\e[31m'
blue='\e[34m'
yellow='\e[33m'

NC='\e[0m' # No Color

function bak {
    ## create a backup of the file, with the same name, same location .bak extension
    ## filename=$1
    echo $MSG" (bak)" >> $1.bak
    cat $1 >> $1.bak
    #echo $1" has a .bak file"
}

function set_file {
    ## cerate a file with the content overwriting everything
    ## filename=$1 content=$2

    if [ -f $1 ];
     then bak $1
    fi
    echo "creating "$1
    echo "$2" > $1
}

function sed_file {
    ## used to replace a line in a file
    ## filename=$1 oldline=$2 newline=$3
    bak $1
    cat $1 > $1.tmp
    sed "s|$2|$3|" $1.tmp > $1
    rm $1.tmp
}

function add_conf {
    ## check if the content string is present, and add if necessery. Single-line content only.
    ## filename=$1 content=$2

    if [ -f $1 ];
     then bak $1
    fi

    if grep -q "$2" $1; then
     echo $1" already has "$2
    else
     echo "adding "$2
     echo "$2" >> $1
    fi
}

function log {
    ## create a log entry
    echo -e ${yellow}$1${NC}
    echo $NOW': '$1 >> $LOG
}

function err {
    ## create a log entry
    echo -e ${red}$1${NC}
    echo $NOW': '$1 >> $LOG
}

## Lablib functions end here.

## srvctl functions

function argument {

if [ -z "$ARG" ]
then
    echo "No $1 supplied .."
    exit
fi

eval $1=$ARG

}

function to_ip {

	local __counter=$1
	local __c=$(( 1 + $__counter / 250 ))
	local __d=$(( 1 + $__counter % 250 ))

	echo $__c"."$__d
}

function to_mac {

	local __counter=$1
	local __c=$(( 1 + $__counter / 250 ))
	local __d=$(( 1 + $__counter % 250 ))

	echo $(printf '%x\n'  $__c)":"$(printf '%x\n'  $__d)
}


function restart_pound {

	systemctl restart pound.service
	service_status=$(systemctl is-active pound.service)

	if [ $service_status == "active" ]
	then 
	  ## Pound, our web-front should never stop.
	  ## Make a copy of configs, just to make sure.
	  ## bak files are for humans, we do a last-cfg here.
	
	  cat /etc/pound-http-pridomains.cfg >   /etc/pound-http-pridomains.last-cfg 	
	  cat /etc/pound-http-subdomains.cfg >   /etc/pound-http-subdomains.last-cfg 
	  cat /etc/pound-https-pridomains.cfg >  /etc/pound-https-pridomains.last-cfg 	
	  cat /etc/pound-https-subdomains.cfg >  /etc/pound-https-subdomains.last-cfg 

	else
	  echo -e ${red}"FAILED. Reverting to last known good pound configuration."${NC}
	
	  cat /etc/pound-http-pridomains.cfg >  /etc/pound-http-pridomains.fail-cfg
	  cat /etc/pound-http-subdomains.cfg >  /etc/pound-http-subdomains.fail-cfg

	  cat /etc/pound-https-pridomains.last-cfg >  /etc/pound-https-pridomains.cfg
	  cat /etc/pound-https-subdomains.last-cfg >  /etc/pound-https-subdomains.cfg

	  systemctl restart pound.service

	fi

	## Display status
  	systemctl status  pound.service

}

function create_certificate { ## for container $C

	## Prepare Certificate creation
	log "Create certificate."

	mkdir $SRV/$C/cert
	##cd $SRV/$C/cert


	ssl_days=1085
	ssl_random=$SRV/$C/cert/random.txt
	ssl_config=$SRV/$C/cert/$C.txt
	ssl_key=$SRV/$C/cert/$C.key
	ssl_org=$SRV/$C/cert/$C.key.org
	ssl_crt=$SRV/$C/cert/$C.crt
	ssl_csr=$SRV/$C/cert/$C.csr
	ssl_pem=$SRV/$C/cert/$C.pem

	set_file $ssl_config "       RANDFILE               = $ssl_random

        [ req ]
        default_bits           = 2048
        default_keyfile        = keyfile.pem
        distinguished_name     = req_distinguished_name
        attributes             = req_attributes
        prompt                 = no
        output_password        = $ssl_password

        [ req_distinguished_name ]
        C                      = HU
        ST                     = Hungary
        L                      = Budapest
        O                      = $CMP
        OU                     = The Lab CA
        CN                     = $C
        emailAddress           = webmaster@$C

 	[ req_attributes ]
        challengePassword              = A challenge password"


	#### create certificate for https ### good howto: http://www.akadia.com/services/ssh_test_certificate.html	

	## Step 1: Generate a Private Key
	openssl genrsa -des3 -passout pass:$ssl_password -out $ssl_key 2048

	## Step 2: Generate a CSR (Certificate Signing Request)

	openssl req -new -passin pass:$ssl_password -passout pass:$ssl_password -key $ssl_key -out $ssl_csr -days $ssl_days -config $ssl_config
	
	## Step 3: Remove Passphrase from Key

	cp $ssl_key $ssl_org
	openssl rsa -passin pass:$ssl_password -in $ssl_org -out $ssl_key	
	
	## Step 4: Generating a Self-Signed Certificate
	## later on, use signed certificates, eg. verisign, startssl or netlock.hu
	## To use your own CA openssl ca -batch -out $ssl_crt -config /etc/pki/[YOU_AS_CA]/openssl.cnf -passin pass:[YOU_AS_CA_PASS] -in $ssl_csr
	## We will generate now a self-signed certificate
	openssl x509 -req -days $ssl_days -passin pass:$ssl_password  -in $ssl_csr -signkey $ssl_key -out $ssl_crt

	## Eventually create a certificate keychain in pem format
	cat $ssl_key >  $ssl_pem
	cat $ssl_crt >> $ssl_pem

}

function create_poundfile { ## for container $C

	set_file $SRV/$C/pound '## srvctl '$C'
Service
                  HeadRequire "Host:.*'$C'.*"
                  BackEnd
                      Address '$(cat $SRV/$C/config.ipv4)'
                      Port    80
                  End
End'


echo '## srvctl generated' > $SRV/$C/pound-http
echo 'Include "'$SRV'/'$C'/pound"' >> $SRV/$C/pound-http



echo '## srvctl generated' > $SRV/$C/pound-https

  if [ -f $SRV/$C/cert/$C.pem ]
  then
	echo 'Cert "'$SRV'/'$C'/cert/'$C'.pem"' >> $SRV/$C/pound-https
  fi

echo 'Include "'$SRV'/'$C'/pound"' >> $SRV/$C/pound-https


}

function create_keypair { ## for user $U

	mkdir /home/$U/.ssh

	## create ssh keypair
	if [ ! -f /home/$U/.ssh/id_rsa.pub ]; then
	   ssh-keygen -t rsa -b 4096 -f /home/$U/.ssh/id_rsa -N '' -C $U@@$(hostname)
	fi

	chown -R $U:$U /home/$U/.ssh
	chmod -R 600 /home/$U/.ssh
	chmod    700 /home/$U/.ssh
}

function get_password {

	## You may want to add your own sillyables, or faorite characters and customy security measures.
	declare -a pwarra=("B" "C" "D" "F" "G" "H" "J" "K" "L" "M" "N" "P" "R" "S" "T" "V" "Z")
	pwla=${#pwarra[@]}

	declare -a pwarrb=("a" "e" "i" "o" "u")
	pwlb=${#pwarrb[@]}	

	declare -a pwarrc=("" "." ":" "@" ".." "::" '@@')
	pwlc=${#pwarrc[@]}

	password=''
	password=$password${pwarra[$(( RANDOM % $pwla ))]}
	password=$password${pwarrb[$(( RANDOM % $pwlb ))]}
	password=$password${pwarra[$(( RANDOM % $pwla ))]}
	password=$password${pwarrb[$(( RANDOM % $pwlb ))]}
	# password=$password${pwarrc[$(( RANDOM % $pwlc ))]}
	password=$password${pwarra[$(( RANDOM % $pwla ))]}
	password=$password${pwarrb[$(( RANDOM % $pwlb ))]}
	password=$password${pwarra[$(( RANDOM % $pwla ))]}
	password=$password${pwarrb[$(( RANDOM % $pwlb ))]}

}

function add_user {

  if [ ! -d "/home/$U" ]; then
	get_password

	adduser $U
	echo $password | passwd $U --stdin

	## Since this is a generated password, we add a note about it for the user?
	echo $password > /home/$U/.password

	log "User: $U password: $password set on $(hostname)"

	create_keypair

  fi
}

function set_file_limits {

    ## You can increase the amount of open files and thus the amount of client connections by using "ulimit -n ". 
    ## For example, to allow pound to accept 5,000 connections and forward 5,000 connection to back end servers (10,000 total) use "ulimit -n 10000".
    ulimit -n 100000

    ## Hint from Tamás Papp to fix Error: Too many open files
    sysctl fs.inotify.max_user_watches=81920
    sysctl fs.inotify.max_user_instances=1024
}

## srvctl functions end here.

log "[$(whoami)@$(hostname) $(pwd)]# $0 $1 $2"


if [ "$CMD" == "--version" ] && $onHS
then

  echo 'srvctl: '$(head $0 | grep "# version ")
  echo 'LXC: '$(lxc-info --version)

fi

if [ "$CMD" == "uninstall" ] && $onHS
then

	yum -y remove libvirt*
	rm -rf /etc/libvirt

	bak /etc/hosts

	echo '127.0.0.1		localhost.localdomain localhost' > /etc/hosts
	echo '::1		localhost6.localdomain6 localhost6' >> /etc/hosts

fi

if [ "$CMD" == "update-install" ] && $onHS
then

### WEB

    ## LXC is also part of docker-io
    #yum install docker-io
    
    ## lxc can be installed as rpm
    #yum -y install lxc lxc-templates

    ## packages needed for compilation and for running
    log "Install Development Tools"
    yum -y groupinstall "Development Tools"
    yum -y install automake
    yum -y install graphviz
    yum -y install libcap-devel
    
    ## to compile it from source
    ## git clone git://github.com/lxc/lxc


    ## we use a version-release now.
    ver="1.0.2"

    log "Install LXC "$ver

    cd /root
    rm -rf lxc

    wget https://github.com/lxc/lxc/archive/lxc-$ver.zip
    unzip lxc-$ver.zip
    mv lxc-lxc-$ver lxc
 
    cd lxc

    log "LXC-building: autogen"
    ./autogen.sh

    log "LXC-building: configure"
    ./configure

    log "LXC-building: make"
    make

    log "LXC-building: install"
    make install

    ## Add export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
    #echo "export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib" >> /root/.bash_profile
    add_conf "export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib" /root/.bash_profile

    log "Configure libvirt network"

## Networking with libvirt
	yum -y install libvirt-daemon-driver-network libvirt-daemon-config-network libvirt-daemon-config-nwfilter

	set_file /etc/libvirt/qemu/networks/default.xml '<network>
  <name>default</name>
  <uuid>00000000-0000-aaaa-aaaa-aaaaaaaaaaaa</uuid>
  <bridge name="inet-br"/>
  <mac address="00:00:00:AA:AA:AA"/>
  <forward/>
  <ip address="192.168.0.1" netmask="255.255.0.0">
    <dhcp>
      <range start="192.168.0.2" end="192.168.255.254"/>
    </dhcp>
  </ip>
</network>
'

set_file /etc/libvirt/qemu/networks/primary.xml '<network>
  <name>primary</name>
  <uuid>00000000-0000-2010-0010-000000000001</uuid>
  <bridge name="srv-net"/>
  <mac address="00:00:10:10:00:01"/>
  <forward/>
  <ip address="10.10.0.1" netmask="255.255.0.0"></ip>
</network>
'

## TODO, .. I think the primary interface - with a gateway - is enough. The default should be kept though.

    ln -s /etc/libvirt/qemu/networks/primary.xml /etc/libvirt/qemu/networks/autostart/primary.xml

    systemctl enable libvirtd.service
    systemctl start  libvirtd.service
    systemctl status libvirtd.service


#### RESTART REQUIRED HERE

    ## srvctl
    mkdir -p /etc/srvctl

    if [ -f /etc/srvctl/counter ];
    then
     log "Counter exists."
    else
     log "Counter does not exist. Creating."
     echo '0' > /etc/srvctl/counter
    fi

    ## setup srvctl enviroment
    mkdir -p $SRV
    mkdir -p $TMP
    mkdir -p /var/srvctl
    mkdir -p /etc/srvctl

    ## this will save a little space. 
    cp /usr/lib/locale/locale-archive /var/srvctl 

    ## TODO: I'm not a distro engineer, but I think there is space for optimalisation.


    ## default path for containers

    echo "lxc.lxcpath="$SRV > /usr/local/etc/lxc/lxc.conf

    ## just in case
    bak /etc/hosts

    ## create ssh key for root
    if [ ! -f /root/.ssh/id_rsa.pub ]; then
    ssh-keygen -t rsa -b 4096 -f /root/.ssh/id_rsa -N ''
    fi

    log "Create Custom template"

    ## Customisations in our template
    cd /usr/local/share/lxc/templates

    set_file lxc-fedora-srv '#!/bin/bash

## password array based variable
declare -a arr=("Ba" "Be" "Bi" "Bo" "Bu" "Ca" "Ce" "Ci" "Co" "Cu" "Da" "De" "Di" "Do" "Du" "Fa" "Fe" "Fi" "Fo" "Fu" "Ga" "Ge" "Gi" "Go" "Gu" "Ha" "He" "Hi" "Ho" "Hu" "Ja" "Je" "Ji" "Jo" "Ju" "Ka" "Ke" "Ki" "Ko" "Ku" "La" "Le" "Li" "Lo" "Lu" "Ma" "Me" "Mi" "Mo" "Mu" "Na" "Ne" "Ni" "No" "Nu" "Pa" "Pe" "Pi" "Po" "Pu" "Ra" "Re" "Ri" "Ro" "Ru" "Sa" "Se" "Si" "So" "Su" "Ta" "Te" "Ti" "To" "Tu" "Va" "Ve" "Vi" "Vo" "Vu" "Za" "Ze" "Zi" "Zo" "Zu")
l=${#arr[@]}
root_password=${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}

'
    chmod 755 lxc-fedora-srv

    cat lxc-fedora >> lxc-fedora-srv
    ## cosmetical TODO remove second #!/bin/bash

    ## disable the root password redefining force
    sed_file lxc-fedora-srv 'chroot $rootfs_path passwd -e root' '## srvctl-disabled: chroot $rootfs_path passwd -e root'
    sed_file lxc-fedora-srv 'Container rootfs and config have been created.' 'Container rootfs and config have been created."'
    ## and do not display the dialog for that subject
    sed_file lxc-fedora-srv 'Edit the config file to check/enable networking setup.' 'exit 0'

    ## Add additional default packages - NOTE: After modifocation of this in a live filesystem, /usr/local/var/cache/lxc/fedora needs to be purged.
    sed_file lxc-fedora-srv '    PKG_LIST="yum initscripts passwd rsyslog vim-minimal openssh-server openssh-clients dhclient chkconfig rootfiles policycoreutils fedora-release"' '    PKG_LIST="yum initscripts passwd rsyslog vim-minimal openssh-server openssh-clients dhclient chkconfig rootfiles policycoreutils fedora-release mc httpd wordpress mariadb mariadb-server postfix mailx sendmail"'

## TODO / ISSUE : dovecot can not be added, as it freezes the install process


    log "Install Pound Reverse Proxy for HTTP" 

    ## The pound-served custom error documents

set_file /var/www/html/414.html '<head></head><body bgcolor="#333"><div id="header" style="background-color:#151515;"><img src="http://'$CDN'/lablogo.png" alt="'$CMP'" style="display: block; margin-left: auto; margin-right: auto; vertical-align: middle"></div><p align="center"><font color="#aaa" style="margin-left: auto; margin-right: auto" size="6px" face="Arial">
<b>Error 414</b> @ '$(hostname)'<br />
Request URI is too long.
</font><p></body>'

set_file /var/www/html/500.html '<head></head><body bgcolor="#333"><div id="header" style="background-color:#151515;"><img src="http://'$CDN'/lablogo.png" alt="'$CMP'" style="display: block; margin-left: auto; margin-right: auto; vertical-align: middle"></div><p align="center"><font color="#aaa" style="margin-left: auto; margin-right: auto" size="6px" face="Arial">
<b>Error 500</b> @ '$(hostname)'<br />
An internal server error occurred. Please try again later.
</font><p></body>'

set_file /var/www/html/501.html '<head></head><body bgcolor="#333"><div id="header" style="background-color:#151515;"><img src="http://'$CDN'/lablogo.png" alt="'$CMP'" style="display: block; margin-left: auto; margin-right: auto; vertical-align: middle"></div><p align="center"><font color="#aaa" style="margin-left: auto; margin-right: auto" size="6px" face="Arial">
<b>Error 501</b> @ '$(hostname)'<br />
Request URI is too long.
</font><p></body>'

set_file /var/www/html/503.html '<head></head><body bgcolor="#333"><div id="header" style="background-color:#151515;"><img src="http://'$CDN'/lablogo.png" alt="'$CMP'" style="display: block; margin-left: auto; margin-right: auto; vertical-align: middle"></div><p align="center"><font color="#aaa" style="margin-left: auto; margin-right: auto" size="6px" face="Arial">
<b>Error 503</b> @ '$(hostname)'<br />
The service is not available. Please try again later.
</font><p></body>'


    ## Pound is a reverse Proxy for http
    yum -y install Pound
    bak /etc/pound.cfg

    mkdir /etc/pound


    set_file /etc/pound.cfg '## srvctl pound.cfg
User "pound"
Group "pound"
Control "/var/lib/pound/pound.cfg"

## Default loglevel is 1
# LogLevel    3

ListenHTTP

    Address 0.0.0.0
    Port    80

    Err414 "/var/www/html/414.html"
    Err500 "/var/www/html/500.html"
    Err501 "/var/www/html/501.html"
    Err503 "/var/www/html/503.html"

    Include "/etc/pound-http-subdomains.cfg"
    Include "/etc/pound-http-pridomains.cfg"

End
ListenHTTPS

    Address 0.0.0.0
    Port    443
    Include "/etc/pound-certificates.cfg"

    Err414 "/var/www/html/414.html"
    Err500 "/var/www/html/500.html"
    Err501 "/var/www/html/501.html"
    Err503 "/var/www/html/503.html"

    Include "/etc/pound-https-subdomains.cfg"
    Include "/etc/pound-https-pridomains.cfg"

    ## The CA provided files have to be included in here.
    # Include "/etc/pound-include-ca.cfg"


End

## Include the default host here, as a fallback.
# Include "/srv/default-host/pound"
'
	echo '## srvctl primary domains' >> /etc/pound-http-pridomains.cfg
	echo '## srvctl subdomains' >> /etc/pound-http-subdomains.cfg

	echo '## srvctl primary domains' >> /etc/pound-https-pridomains.cfg
	echo '## srvctl subdomains' >> /etc/pound-https-subdomains.cfg


	systemctl enable pound.service

set_file_limits

### E-mail

yum -y install postfix

pc=/etc/postfix/main.cf

sed_file $pc 'inet_interfaces = localhost' '#inet_interfaces = localhost'


if grep -q  '## srvctl postfix configuration directives' $pc; then
 log "Skipping Postfix configuration, as it seems to be configured."
else

echo '
## srvctl postfix configuration directives
## RECIEVING

## Listen on ..
inet_interfaces = all

## use /etc/hosts instead of dns-query
lmtp_host_lookup = native
smtp_host_lookup = native
## in addition, this might be enabled too.
# smtp_dns_support_level = disabled

## dont forget to postmap /etc/postfix/relaydomains
relay_domains = $mydomain, hash:/etc/postfix/relaydomains

## SENDING
## SMTPS
smtpd_tls_CAfile =    /etc/postfix/postfix-ca-bundle.pem
smtpd_tls_cert_file = /etc/postfix/postfix.crt.pem
smtpd_tls_key_file =  /etc/postfix/postfix.key.pem
smtpd_tls_security_level = may
smtpd_use_tls = yes

## We use cyrus for PAM authentication of local users
smtpd_sasl_type = cyrus

## We could use dovecot too.
#smtpd_sasl_type = dovecot
#smtpd_sasl_path = private/auth

smtpd_sasl_auth_enable = yes
smtpd_sasl_authenticated_header = yes
smtpd_recipient_restrictions = permit_mynetworks, permit_sasl_authenticated
##, check_recipient_access, reject_unauth_destination
smtpd_sasl_local_domain = d250.hu

## Max 25MB mail size
message_size_limit=26214400 
' >> $pc

fi


echo '# srvctl postfix relaydomains' >> /etc/postfix/relaydomains

postmap /etc/postfix/relaydomains
systemctl enable postfix.service
systemctl start postfix.service

log "Set /etc/aliases"

## We will mainly use these files to copy over to clients. Main thing is: info should not be aliased.
set_file /etc/aliases '
#
#  Aliases in this file will NOT be expanded in the header from
#  Mail, but WILL be visible over networks or from /bin/mail.
#
#	>>>>>>>>>>	The program "newaliases" must be run after
#	>> NOTE >>	this file is updated for any changes to
#	>>>>>>>>>>	show through to sendmail.
#

# Basic system aliases -- these MUST be present.
mailer-daemon:	postmaster
postmaster:	root

# General redirections for pseudo accounts.
bin:		root
daemon:		root
adm:		root
lp:		root
sync:		root
shutdown:	root
halt:		root
mail:		root
news:		root
uucp:		root
operator:	root
games:		root
gopher:		root
ftp:		root
nobody:		root
radiusd:	root
nut:		root
dbus:		root
vcsa:		root
canna:		root
wnn:		root
rpm:		root
nscd:		root
pcap:		root
apache:		root
webalizer:	root
dovecot:	root
fax:		root
quagga:		root
radvd:		root
pvm:		root
amandabackup:	root
privoxy:	root
ident:		root
named:		root
xfs:		root
gdm:		root
mailnull:	root
postgres:	root
sshd:		root
smmsp:		root
postfix:	root
netdump:	root
ldap:		root
squid:		root
ntp:		root
mysql:		root
desktop:	root
rpcuser:	root
rpc:		root
nfsnobody:	root

ingres:		root
system:		root
toor:		root
manager:	root
dumper:		root
abuse:		root

newsadm:	root #news
newsadmin:	root #news
usenet:		root #news
ftpadm:		root #ftp
ftpadmin:	root #ftp
ftp-adm:	root #ftp
ftp-admin:	root #ftp
www:		webmaster
webmaster:	root
noc:		root
security:	root
hostmaster:	root
#info:		postmaster
#marketing:	postmaster
#sales:		postmaster
#support:	postmaster


# trap decode to catch security attacks
decode:		root

# Person who should get roots mail
#root:		marc
'



newaliases

## IMAP4S proxy

yum -y install perdition

## TODO: install certtificates!!

echo "Install your certificates for perdition! "

set_file /etc/perdition/perdition.conf '#### srvctl tuned perdition.conf
## Logging settings

# Turn on verbose debuging.
#debug
#quiet

# Log all comminication recieved from end-users or real servers or sent from perdition.
# Note: debug must be in effect for this option to take effect.

connection_logging

log_facility mail

## Basic settings

## NOTE: possibly listen only on the external-facing interface, and local-dovecot only on 127.0.0.1
bind_address 0.0.0.0 

domain_delimiter @


#### IMPORTANT .. the symbolic link .so.0 does not work. Full path is needed to real file.
map_library /usr/lib64/libperditiondb_posix_regex.so.0.0.0
map_library_opt /etc/perdition/popmap.re

no_lookup

ok_line "Reverse-proxy IMAP4S service lookup OK!"

protocol IMAP4S

## If no matches found in popmap.re
outgoing_server localhost

## This is also doing some error reporting, but it works
pid_file /var/run/perdition.pid

strip_domain remote_login

## For the default dovecot config, no ssl verification is needed
ssl_no_cert_verify
ssl_no_cn_verify
'

set_file /etc/perdition/popmap.re '#### srvctl tuned popmap.re

# (.*)@'$(hostname)': localhost

## you may add email domains here that should be located at localhost.

(.*)@(.*): $2
'

systemctl enable perdition-imap4s.service
systemctl start perdition-imap4s.service
systemctl status perdition-imap4s.service
log "Install SSL certificates for perdition in /etc/perdition (perdition.key.pem perdition.crt.pem perdition.ca.pem) "

## configure DNS server

yum -y install bind bind-utils

set_file /etc/named.conf '// srvctl generated named.conf

options {
    listen-on port 53 { any; };
    listen-on-v6 port 53 { any; };
    directory 	"/var/named";
    dump-file 	"/var/named/data/cache_dump.db";
    statistics-file "/var/named/data/named_stats.txt";
    memstatistics-file "/var/named/data/named_mem_stats.txt";
    allow-query     { any; };
    recursion yes;
    dnssec-enable yes;
    dnssec-validation yes;
    dnssec-lookaside auto;
    bindkeys-file "/etc/named.iscdlv.key";
    managed-keys-directory "/var/named/dynamic";
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};

zone "." IN {
    type hint;
    file "named.ca";
};

include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";

include "/etc/named.conf.local";
'

set_file /etc/named.conf.local '## srvctl generated 
'

rsync -a /usr/share/doc/bind/sample/etc/named.rfc1912.zones /etc
rsync -a /usr/share/doc/bind/sample/var/named /var
mkdir /var/named/dynamic

chown -R named:named /var/named


## TODO: firewall-config. open tcp port 993 permanently

## TODO install dovecot, add listen = 127.0.0.1 to dovecot.conf
## and enable
  # Postfix smtp-auth ### ENABLE with srvctl!
  #unix_listener /var/spool/postfix/private/auth {
  #  mode = 0666
  #}

## TODO Create SMTPD Auth proxy method

log "Creating devel-shortcuts in /shortcuts"
## some quick links for root
## this has no real imporance so it can be any directory for your convinience
mkdir /shortcuts
cd /shortcuts

ln -s $SRV
ln -s /etc/hosts
ln -s /etc/pound.cfg
ln -s /etc/pound-http-pridomains.cfg
ln -s /etc/pound-http-subdomains.cfg
ln -s /etc/pound-https-pridomains.cfg
ln -s /etc/pound-https-subdomains.cfg
ln -s /usr/bin/srvctl srvctl
ln -s /usr/local/etc/lxc/lxc.conf
ln -s /usr/local/share/lxc/templates/lxc-fedora-srv
ln -s /usr/local/var/cache/lxc/fedora cache-lxc-fedora


log "Reboot required. Please verify srv-net functionality."

if [ -s /root/.ssh/authorized_keys  ]
then
  log "ATTENTION! Disabled password based ssh login. ADD YOUR SSH KEY!"
  sed_file /etc/ssh/sshd_config "PasswordAuthentication yes" "PasswordAuthentication no"
  echo "Note: to undo, you may run:  cat /etc/ssh/sshd_config.bak > /etc/ssh/sshd_config"
fi

fi # install

#### COMMANDS ####

## This is mainly for dev! This should be disabled in production!
if [ "$CMD" == "reset-install" ] && $onHS
then

### As I said, ONLY if you really need this.
#log "WARNING! Command disabled."
#exit

 for C in $(ls $SRV)
 do
	lxc-stop -k -n $C
 done

 rm -rf $SRV/*
 rm -rf /root/.ssh/known_hosts
 rm -rf /etc/pound/*

 echo '## srvctl pound-http-pridomains.cfg' > /etc/pound-http-pridomains.cfg
 echo '## srvctl pound-http-subdomains.cfg' > /etc/pound-http-subdomains.cfg
 echo '## srvctl pound-https-pridomains.cfg' > /etc/pound-https-pridomains.cfg
 echo '## srvctl pound-https-subdomains.cfg' > /etc/pound-https-subdomains.cfg

 systemctl stop pound.service

 echo '127.0.0.1		localhost.localdomain localhost' > /etc/hosts
 echo '::1		localhost6.localdomain6 localhost6' >> /etc/hosts

 echo 'DONE!'
fi

##### srvctl general functions

## start or restart service
if [ "$CMD" == "restart" ] && $onHS
then
argument service

	if [ "$ARG" == "pound" ]
	then

	  restart_pound	
	
	else

	systemctl restart $ARG.service
	systemctl status  $ARG.service

	fi ## pound.service


fi ## start


#### srvctl run functions


function set_is_running {
	
	info=$(lxc-info -s -n $C)
	state=${info:16}
	if [ "$state" == "RUNNING" ]
	then
	  is_running=true
	else
	  is_running=false
	fi
}


function get_info {

	printf ${NC}"%-48s"${NC} $C
}

function get_ip {

	ipv4=''
	ip=$(cat $SRV/$C/config.ipv4)

	if [ -z $ip ] 
	then
	  ipv4=$(grep "lxc.network.ipv4" $SRV/$C/config)
	  ip=${ipv4:19:-2}
	  echo $ip > $SRV/$C/config.ipv4
	fi

	printf ${NC}"%-14s"${NC} $ip

}

function get_state {

	ms='STOPPED'
	pcs=''
	msc=${red}	

	ip=$(cat $SRV/$C/config.ipv4)

	info=$(lxc-info -s -n $C)
	state=${info:16}

	if [ "$state" == "RUNNING" ] && [ ! -z "$ip" ]
	then
	ping_ms=$(ping -r -I srv-net -W 1 -c 1 $ip | grep rtt) 
	msc=$green
	ms=${ping_ms:23:5}"ms"
	else
	ms=$state
	fi
	
	printf ${msc}"%-10s"${NC} $ms


}

function get_pound_state {

	ps='none'
	if [ ! -z $ip ] && [ "$(systemctl is-active pound.service)" = "active" ]
	then
	  ps=$(poundctl -c /var/lib/pound/pound.cfg | grep $ip'' | tail -c 5)
	  
	fi
	printf ${yellow}"%-5s"${NC} $ps

}

function get_disk_usage {

	du=$(du -hs $SRV/$C | head -c 4 )

	printf ${yellow}"%-5s"${NC} $du
}

function get_dig_A {

	dig_A=$(dig +time=1 +short $C)	

	if [ "$dig_A" == "$HOSTIPv4" ]
	then
		printf ${yellow}"%-3s"${NC} "OK"
	else
		printf ${red}"%-3s"${NC} "??"
	fi


	#dig=$(nslookup $C | grep -A 3 answer | tail -n 2 | head -n 1)

	#printf ${yellow}"%-16s"${NC} ${dig_result}
}

function get_dig_MX {

	dig_MX=$(dig +time=1 +short $(dig +time=1 +short $C MX | cut -d \  -f 2))
	

	if [ "$dig_MX" == "$HOSTIPv4" ]
	then
		printf ${yellow}"%-3s"${NC} "OK"
	else
		printf ${red}"%-3s"${NC} "??"
	fi
}

function get_users {

	touch $SRV/$C/users

	users=$(cat $SRV/$C/users | sed ':a;N;$!ba;s/\n/|/g')

	printf ${yellow}"%-16s"${NC} ${users:0:16}
}

function get_http_response {

	#indexpage_curl=$(curl -s $C)

	#indexpage_tag=$(echo $indexpage_curl | grep "<title>")

	#indexpage_title=$(curl -s $C | grep "<title>")

	curli=$(curl -s -I http://$C | head -n 1)
	resp=${curli:9:3}	
	
	if [ "$resp" == "200" ]
	then 
	  resp_color=$green
	else
	  resp_color=$red
	fi

	printf ${resp_color}"%-4s"${NC} "$resp"

}

## report status
if [ "$CMD" == "status" ] && $onHS
then
	echo ''

	printf ${yellow}"%-10s"${NC} "RESPONSE"
	printf ${yellow}"%-48s"${NC} "HOSTNAME"
	
	echo ''

 for C in $(lxc-ls)
 do
	get_state
	get_info

	echo ''
 done

	echo ''
	
fi

## report status of all details
if [ "$CMD" == "status-all" ] && $onHS
then
	echo "Hostname: "$(hostname)
	echo "Uptime:   "$(uptime)
	free -h | head -n 2

	echo ''
	printf ${yellow}"%-10s"${NC} "STATUS"
	printf ${yellow}"%-48s"${NC} "HOSTNAME"
	printf ${yellow}"%-14s"${NC} "IP-LOCAL"
	printf ${yellow}"%-3s"${NC} "IN"
	printf ${yellow}"%-3s"${NC} "MX"	
	printf ${yellow}"%-5s"${NC} "DISK"
	printf ${yellow}"%-16s"${NC} "USERs"
	printf ${yellow}"%-5s"${NC} "HTTP"
	printf ${yellow}"%-4s"${NC} "RES"


	echo ''

 for C in $(lxc-ls)
 do

	get_state
	get_info
	get_ip
	get_dig_A
	get_dig_MX
	get_disk_usage
	get_users
	get_pound_state
	get_http_response




	echo ''
 done

	echo ''
	
fi

## startall
if [ "$CMD" == "start-all" ] && $onHS
then

set_file_limits

 for C in $(lxc-ls)
 do


	set_is_running
	
	if ! $is_running
	then
	  printf ${yellow}"%-10s"${NC} "STARTED"	
	else
	  get_state
	fi	

	get_info

	if ! $is_running
	then
	  lxc-start -n $C -d
	fi

	echo ''


 done	
fi

## killall
if [ "$CMD" == "kill-all" ] && $onHS
then
 for C in $(lxc-ls)
 do

	set_is_running

	if $is_running
	then
	  printf ${yellow}"%-10s"${NC} "KILLING"		
	else
	get_state
	fi

	get_info

	if $is_running
	then
	  lxc-stop -k -n $C
	fi

	echo ''	
	

 done	
fi

## stopall
if [ "$CMD" == "stop-all" ] && $onHS
then
 for C in $(lxc-ls)
 do

	set_is_running

	if $is_running
	then
	  printf ${yellow}"%-10s"${NC} "SHUTDOWN"	
	else 
	get_state
	fi

	get_info

	if $is_running
	then
	  ssh $C shutdown -P now
	fi

	echo ''	

 done	
fi

## stopall
if [ "$CMD" == "reboot-all" ] && $onHS
then
 for C in $(lxc-ls)
 do

	set_is_running

	if $is_running
	then
	  printf ${yellow}"%-10s"${NC} "REBOOT!"	
	else 
	get_state
	fi

	get_info

	if $is_running
	then
	  ssh $C reboot
	fi

	echo ''	

 done	
fi

## exec-all 'something' (or with "")ssh  
if [ "$CMD" == "exec-all" ] && $onHS
then

argument command

 for C in $(lxc-ls)
 do

	ssh $C "$ARG"

	get_ip
	get_pound_state
	get_state
	get_info

	echo ''	

 done	
fi


if [ "$CMD" == "add-user" ] && $onHS
then

	argument U

	add_user

fi ## adduser



## regenerate configs 
if [ "$CMD" == "regenerate" ] && $onHS
then

	all_ok=true

## SRY, IMPLEMENTATION INCOMPLETE. TODO: fix
#exit

 ## regenerate etc_hosts
 echo '# srvctl generated' > $TMP/hosts
 echo '127.0.0.1		localhost.localdomain localhost' >> $TMP/hosts
 echo '::1		localhost6.localdomain6 localhost6' >> $TMP/hosts
 echo '' >> $TMP/hosts
 echo '' > $TMP/relaydomains

 for C in $(lxc-ls)
 do

	ip=$(cat $SRV/$C/config.ipv4)

	if [ -z $ip ] 
	then
	  ipv4=$(grep "lxc.network.ipv4" $SRV/$C/config)
	  ip=${ipv4:19:-2}
	  echo $ip > $SRV/$C/config.ipv4
	fi


	if [ -z $ip ] 
	then
		echo "ERROR tmp: hosts - MISSING IP ADDRESS: "$C
		all_ok=false
	else
 	  echo $ip'		'$C >>  $TMP/hosts
	  echo $ip'		mail.'$C >>  $TMP/hosts
	  echo ''  >>  $TMP/hosts

	  echo $C' #' >>  $TMP/relaydomains
	fi
 done ## regenerated etc_hosts

 bak /etc/hosts
 rsync -a $TMP/hosts /etc

 bak /etc/postfix/relaydomains
 rsync -a $TMP/relaydomains /etc/postfix/relaydomains
 postmap /etc/postfix/relaydomains

 ## regenerate known hosts
 echo '# srvctl generated' > $TMP/known_hosts
 
 for C in $(lxc-ls)
 do
	set_is_running

	if $is_running
	then
 	#echo 'OK: '$C

	ip=$(cat $SRV/$C/config.ipv4)
	
	echo "# "$C >> $TMP/known_hosts
	2>/dev/null 1>/dev/null ssh-keyscan -t rsa -H $ip >> $TMP/known_hosts
	2>/dev/null 1>/dev/null ssh-keyscan -t rsa -H $C >> $TMP/known_hosts
	echo '' >> $TMP/known_hosts

	
	else
 		echo "WARNING tmp: .ssh known_hosts - VE NOT RUNNING: "$C
	fi
 done ## regenerated known_hosts

 ## regenerate pound files
 echo '# srvctl generated' > $TMP/pound-http-subdomains.cfg
 echo '# srvctl generated' > $TMP/pound-http-pridomains.cfg
 echo '# srvctl generated' > $TMP/pound-https-subdomains.cfg
 echo '# srvctl generated' > $TMP/pound-https-pridomains.cfg


 for C in $(lxc-ls)
 do

	set_is_running
	if $is_running
	then

		if [ ! -f $SRV/$C/pound ]
		then
			create_poundfile
			echo "NOTICE Pound file created for "$C
		fi	
	
		if [ ! -f $SRV/$C/cert/$C.pem ]
		then
			rsync -a $SRV/$C/cert $TMP
			echo "WARNING - CERTIFICIATE MISSING: CREATING NEW "$C
			create_certificate		
		fi


		if [ -f $SRV/$C/cert/ca-bundle.pem ]
		then
			cert_status=$(openssl verify -CAfile $SRV/$C/cert/ca-bundle.pem $SRV/$C/cert/$C.pem | tail -n 1 | tail -c 3)
		else
			cert_status=$(openssl verify $SRV/$C/cert/$C.pem | tail -n 1 | tail -c 3)
		fi

		if [ ! -f $SRV/$C/pound-http ]
		then
			echo '## srvctl generated' > $SRV/$C/pound-http
			echo 'Include "'$SRV'/'$C'/pound"' >> $SRV/$C/pound-http
		fi

		if [ "$cert_status" == "OK" ]
		then 
			if [ ! -f $SRV/$C/pound-https ]
			then
				echo '## srvctl generated' > $SRV/$C/pound-https
				echo 'Cert "'$SRV'/'$C'/cert/'$C'.pem"' >> $SRV/$C/pound-https
				echo 'Include "'$SRV'/'$C'/pound"' >> $SRV/$C/pound-https
			fi
		else

			echo '## srvctl generated - Check certificate!' > $SRV/$C/pound-https
			echo '# Cert "'$SRV'/'$C'/cert/'$C'.pem"' >> $SRV/$C/pound-https
			echo 'Include "'$SRV'/'$C'/pound"' >> $SRV/$C/pound-https
			echo "WARNING! - CERTIFICATE CHECK FAILED ON "$C
			all_ok=false 
		fi




		if (( $(echo $C | grep -o "\." | grep -c "\.") > 1 )) 
		then 
		  echo 'Include "'$SRV'/'$C'/pound-http"' >> $TMP/pound-http-subdomains.cfg
		  echo 'Include "'$SRV'/'$C'/pound-https"' >> $TMP/pound-https-subdomains.cfg
		else
		  echo 'Include "'$SRV'/'$C'/pound-http"' >> $TMP/pound-http-pridomains.cfg
		  echo 'Include "'$SRV'/'$C'/pound-https"' >> $TMP/pound-https-pridomains.cfg
		fi

	else
 		echo "WARNING tmp: pound-check skip - VE NOT RUNNING: "$C
	fi



 done ## regenerated pound files

log "Updateing regenerated pound config files in /etc" 	

bak /etc/pound-http-subdomains.cfg
bak /etc/pound-http-pridomains.cfg
bak /etc/pound-https-subdomains.cfg
bak /etc/pound-https-pridomains.cfg

rsync -a $TMP/pound-http-subdomains.cfg /etc
rsync -a $TMP/pound-http-pridomains.cfg /etc
rsync -a $TMP/pound-https-subdomains.cfg /etc
rsync -a $TMP/pound-https-pridomains.cfg /etc


### User checks
	## for root
	if [ ! -f /root/.ssh/id_rsa.pub ]
	then
	  echo "FATAL ERROR - NO KEYPAIR FOR ROOT!"
	  all_ok=false
	fi

	if [ ! -f /root/.ssh/authorized_keys ]
	then
	  echo "WARNING - NO authorized_keys FOR ROOT!"
	  echo '' >> /root/.ssh/authorized_keys
	fi

rsync -a $TMP/known_hosts /root/.ssh


  ## First of all, make sure all users we have defined for sites, are all present.
 log "Updateing user-list."
 for C in $(lxc-ls)
 do
	
	for U in $(cat $SRV/$C/users)
	do
		
		
		#echo "User: $U at $C"

		## if the user doesent exists ... well, create it.
		add_user

	done
 done



  ## for regular users
  for U in $(ls /home)
  do

	#echo $U

	if [ ! -f /home/$U/.ssh/id_rsa.pub ]
	then
	  echo "NOTE - CREATING KEYPAIR FOR USER "$U
	  create_keypair
	fi

	if [ -f /home/$U/.ssh/known_hosts ]
	then
		bak /home/$U/.ssh/known_hosts
	fi
	rsync -a $TMP/known_hosts /home/$U/.ssh
	chown $U:$U /home/$U/.ssh/known_hosts


	if [ ! -f /home/$U/.ssh/authorized_keys ]
	then
	  rsync -a /root/.ssh/authorized_keys /home/$U/.ssh
	  ## TODO: Add authorised keys from users here
	  chown $U:$U /home/$U/.ssh/authorized_keys
	fi

  done ## usercheck


 log "Updateing user-structure."
 for C in $(lxc-ls)
 do

	cat /root/.ssh/id_rsa.pub > $SRV/$C/rootfs/root/.ssh/authorized_keys
	chmod 600 $SRV/$C/rootfs/root/.ssh/authorized_keys

	mnt=$SRV/$C/fstab
	echo "/var/srvctl $SRV/$C/rootfs/var/srvctl none ro,bind 0 0" > $mnt
	
	for U in $(cat $SRV/$C/users)
	do
		

		## Add users local public key to container root user
		if [ -f /home/$U/.ssh/id_rsa.pub ]
		then
			bak $SRV/$C/rootfs/root/.ssh/authorized_keys
			cat /home/$U/.ssh/id_rsa.pub >> $SRV/$C/rootfs/root/.ssh/authorized_keys
		else
			echo "NO SYSTEM-USER "$U
		fi

		mkdir -p /home/$U/$C/mnt
		chown -R $U:$U /home/$U/$C

		mkdir -p $SRV/$C/rootfs/mnt/$U

		echo "/home/$U/$C/mnt $SRV/$C/rootfs/mnt/$U none rw,bind 0 0" >> $mnt

	done
 done


## Update DNS named/bind configs
 named_conf_local=$TMP/named.conf.local
 echo '## srvctl named.conf.local' > $named_conf_local
 for C in $(lxc-ls)
 do
	echo 'include "'$SRV'/'$C'/named.conf";' >> $named_conf_local

	named_conf=$SRV/$C/named.conf
	named_zone=$SRV/$C/named.zone

	#if [ ! -f $named_conf ]
	#then
		echo '## srvctl named.conf '$C > $named_conf
		echo 'zone "'$C'" {' >> $named_conf
		echo '	type master;'  >> $named_conf
		echo '	file "'$named_zone'";' >> $named_conf
		echo '};' >> $named_conf
	#fi

	#if [ ! -f $named_zone ]
	#then

set_file $named_zone '$TTL 1D
@	IN SOA	@ '$C'. (
					0	; serial
					1D	; refresh
					1H	; retry
					1W	; expire
					3H )	; minimum
	NS	@
	A	'$HOSTIPv4'
	AAAA	::1'

	#fi

 done

 bak /etc/named.conf.local
 rsync -a $named_conf_local /etc

 systemctl restart named.service
 systemctl status named.service

 ## Finalise

	if $all_ok
	then
		echo "ALL_OK!"
	else
		echo -e ${red}"CRITICAL ERRORS FOUND! Please fix!."${NC}
	fi	

fi ## regenerate




## reMOVE host
if [ "$CMD" == "remove" ] && $onHS
then

	argument C 

	lxc-stop -k -n $ARG

	sed_file /etc/pound-http-pridomains.cfg 'Include "'$SRV'/'$C '## REMOVED '$C' '$NOW
	sed_file /etc/pound-http-subdomains.cfg 'Include "'$SRV'/'$C '## REMOVED '$C' '$NOW
	sed_file /etc/pound-https-pridomains.cfg 'Include "'$SRV'/'$C '## REMOVED '$C' '$NOW
	sed_file /etc/pound-https-subdomains.cfg 'Include "'$SRV'/'$C '## REMOVED '$C' '$NOW


	if [ -d "$SRV/$C" ]; then
	  echo "Container folder does exists"
	  ## trash it! .. to TMP

	  rsync -a $SRV/$C $TMP
	  rm -fr $SRV/$C

	fi

	restart_pound

fi ## reMOVE

## add new host
if [ "$CMD" == "add" ] && $onHS
then

	argument C 

	if [ -d $SRV/$C ]; then
	  err "$SRV/$C already exists! Exiting"
	  exit 11
	fi

	## $C - container / domain name
	C=$(echo $C | grep -P '(?=^.{6,254}$)(^(?:(?!\d+\.)[a-zA-Z0-9_\-]{1,63}\.?)+(?:[a-zA-Z]{2,})$)')
	## Is'nt it a FQDN?

	if [ -z "$C" ]
	then
	  err "$C failed the domain regexp check. Exiting."
	  exit 10
	fi

	counter=$(($(cat /etc/srvctl/counter)+1))
	echo $counter >  /etc/srvctl/counter

	echo $counter > $SRV/$C/config.counter

	if (( $(echo $C | grep -o "\." | grep -c "\.") > 1 )) 
	then 
	SUBDOMAIN=true
	log "Adding subdomain #$counter $C"
	else
	SUBDOMAIN=false
	log "Adding domain #$counter $C"
	fi



	## This arguiment is given as enviroment variable
	#root_prompt_password=no


	log "Create container."
	## templates are usually in /usr/local/share/lxc/templates, lxc-fedora-srv has to be installed!
	lxc-create -n $C -t fedora-srv

	log "Container created."
	## TODO check, if it really is.

	#mkdir -p $SRV/$C 
	
	cfg=$SRV/$C/config
	mnt=$SRV/$C/fstab
	rootfs=$SRV/$C/rootfs

	mac=$(to_mac $counter)
	ip=$(to_ip $counter)	

	echo "10.10."$ip > $SRV/$C/config.ipv4

	echo "# Template for srvctl created fedora container #"$counter >	$cfg
	echo "lxc.network.type = veth" >> $cfg
	echo "lxc.network.flags = up" >> $cfg
	echo "lxc.network.link = inet-br" >> $cfg
	echo "lxc.network.hwaddr = 00:00:00:aa:"$mac >> $cfg
	echo "" >> $cfg

	echo "lxc.network.type = veth" >> $cfg
	echo "lxc.network.flags = up" >> $cfg
	echo "lxc.network.link = srv-net" >> $cfg
	echo "lxc.network.hwaddr = 00:00:10:10:"$mac >> $cfg
	echo "lxc.network.ipv4 = 10.10."$ip"/8" >> $cfg
	echo "" >> $cfg

	echo "lxc.rootfs = $SRV/$C/rootfs" >> $cfg
	echo "lxc.include = /usr/local/share/lxc/config/fedora.common.conf" >> $cfg
	echo "lxc.utsname = $C" >> $cfg
	echo "lxc.autodev = 1" >> $cfg
	echo "" >> $cfg
	echo "lxc.mount = $SRV/$C/fstab" >> $cfg

	echo "/var/srvctl $SRV/$C/rootfs/var/srvctl none ro,bind 0 0" >> $mnt


	mkdir -m 700 $SRV/$C/rootfs/root/.ssh
	cat /root/.ssh/id_rsa.pub > $SRV/$C/rootfs/root/.ssh/authorized_keys
	chmod 700 $SRV/$C/rootfs/root/.ssh/authorized_keys

	## Container should be in the same timezone as the host.
	rsync -a /etc/localtime $SRV/$C/rootfs/etc

	## Container should have the same aliases as the host. (Important here is to disable info)
	rsync -a /etc/aliases $SRV/$C/rootfs/etc
	rsync -a /etc/aliases.db $SRV/$C/rootfs/etc

	echo '

# srvctl configuration
## Listen on ..
inet_interfaces = all

## If required Catch all mail defined in ..
# virtual_alias_maps = hash:/etc/postfix/catchall

## And send it to ..
home_mailbox = Maildir/

## Max 25MB mail size
message_size_limit=26214400


	' >> $SRV/$C/rootfs/etc/postfix/main.cf

	echo "@$C root" > $SRV/$C/rootfs/etc/postfix/catchall
	postmap $SRV/$C/rootfs/etc/postfix/catchall



	## Add IP to hosts file
	echo "10.10.$ip		$C"  >> /etc/hosts
	echo "10.10.$ip		mail.$C"  >> /etc/hosts
	echo ""  >> /etc/hosts

	echo "$C #$ip"  >> /etc/postfix/relaydomains

	postmap /etc/postfix/relaydomains

	## enable the webserver
	ln -s '/usr/lib/systemd/system/httpd.service' $rootfs'/etc/systemd/system/multi-user.target.wants/httpd.service'
	ln -s '/usr/lib/systemd/system/mariadb.service' $rootfs'/etc/systemd/system/multi-user.target.wants/mariadb.service'
	ln -s '/usr/lib/systemd/system/postfix.service' $rootfs'/etc/systemd/system/multi-user.target.wants/postfix.service'
	##ln -s '/usr/lib/systemd/system/dovecot.service' $rootfs'/etc/systemd/system/multi-user.target.wants/dovecot.service'

	## set (fix?) hostname
	echo $C > $rootfs/etc/hostname

	## to ease life, we also have a mysql root password in this file
	ln -s $rootfs/etc/mysqldump.conf $SRV/$C

	## and we keep a note about the owner
	ln -s ./rootfs/etc/owner $SRV/$C

	
	## set default index page 
	index=$rootfs/var/www/html/index.html
	echo '<head></head><body bgcolor="#333"><div id="header" style="background-color:#151515;">
	<img src="lablogo.png" alt="'$CMP'" style="display: block; margin-left: auto; margin-right: auto; vertical-align: middle"></div>
	<p align="center"><font color="#aaa" style="margin-left: auto; margin-right: auto" size="6px" face="Arial">' > $index

	echo '<b>'$C'</b> @ '$(hostname) >> $index

	echo '</font><p></body>' >> $index

	cp /var/www/html/lablogo.png $rootfs/var/www/html
	cp /var/www/html/favicon.ico $rootfs/var/www/html

	## make the installation smaller	
	rm $rootfs/usr/lib/locale/locale-archive
	mkdir $rootfs/var/srvctl
	ln -s /var/srvctl/locale-archive $rootfs/usr/lib/locale/locale-archive 
	
	rm -rf $rootfs/var/cache/yum/*

	## add symlink to client-srvctl

	ln -s /var/srvctl/srvctl $rootfs/bin/srvctl

	create_certificate
	create_poundfile


	if $SUBDOMAIN 
	then
	  echo 'Include "'$SRV'/'$C'/pound-http"' >> /etc/pound-http-subdomains.cfg
	  echo 'Include "'$SRV'/'$C'/pound-https"' >> /etc/pound-https-subdomains.cfg
	else
	  echo 'Include "'$SRV'/'$C'/pound-http"' >> /etc/pound-http-pridomains.cfg
	  echo 'Include "'$SRV'/'$C'/pound-https"' >> /etc/pound-https-pridomains.cfg
	fi

	log "Restarting Pound."
	restart_pound
	
	#### START #### 
	log "Starting container."	

	## Start the container maybe
	lxc-start -n $C -d	

	# TODO install and configure dovecot

	log "$C - 10.10."$ip" started."

	## Add to host's root's known_hosts after the container booted
	echo '' >> /root/.ssh/known_hosts
	$(sleep 15 && $( 2>/dev/null 1>/dev/null ssh-keyscan -t rsa -H 10.10.$ip >> /root/.ssh/known_hosts)) &
	$(sleep 15 && $( 2>/dev/null 1>/dev/null ssh-keyscan -t rsa -H $C >> /root/.ssh/known_hosts)) &
	

	## Dev-note .. I was worried that unencrypted http between the host and a container can be sniffed from another container.
	## My attempts to do so, did not workk, therefore I kept this concept of the containers sitting together on srv-net with static IP's

fi ## srvctl add


################### CLIENT FUNCTIONS ###########
#exit
#!/bin/bash
################################################



##ln -s /var/srvctl/srvctl /bin/srvctl

if [ "$CMD" == "install-wordpress" ] && $onVE
then

echo install-wordpress

yum -y install wordpress
yum -y install php
yum -y install mariadb mariadb-server 
systemctl start mariadb.service
systemctl enable mariadb.service
systemctl restart httpd.service

fi ## install-wordpress

if [ "$CMD" == "import" ] && $onVE
then
echo "import db "$2

mysql < $2

mysql -u root -e "show databases;"

fi ## import db

if [ "$CMD" == "config" ] && $onVE
then

echo config

## chmod
chown -R apache:apache /var/www/html/*

if [ -f /var/www/html/wp-config.php ]; then
    echo "wp-config.php detected!"

rm -rf /var/www/stats

sed -i 's/\r$//' /var/www/html/wp-config.php

cat /var/www/html/wp-config.php | grep "DB_NAME"
db_db=$(cat /var/www/html/wp-config.php | grep "DB_NAME")
db_dbf=${db_db:19:-3}

## Override
#db_dbf="drdugo_sevsam"

echo $db_dbf


mysql < /var/srvctl/20140324010005/$db_dbf.sql

mysql -u root -e "show databases;"

owner=$(echo $db_dbf | cut -f1 -d"_" )

echo $owner > /etc/owner

cat /var/www/html/wp-config.php | grep "DB_USER"
db_u=$(cat /var/www/html/wp-config.php | grep "DB_USER")
db_usr=${db_u:19:-3}

## Override
#db_usr="drdugo_sevsam"

echo $db_usr

cat /var/www/html/wp-config.php | grep "DB_PASSWORD"
db_p=$(cat /var/www/html/wp-config.php | grep "DB_PASSWORD")
db_pwd=${db_p:23:-3}

## Override
#db_pwd="zt7Er34W"

echo $db_pwd


SQL="GRANT ALL ON *.* TO '$db_usr'@'localhost' IDENTIFIED BY '$db_pwd'; flush privileges;"

echo "(WORDPRESS) $SQL"

mysql -u root -e "$SQL"

fi ## wordpress

if [ -f /var/www/html/configuration.php ]; then
    echo "Joomla configuration.php detected!"

rm -rf /var/www/stats

sed -i 's/\r$//' /var/www/html/configuration.php

cat /var/www/html/configuration.php | grep "db "
db_db=$(cat /var/www/html/configuration.php | grep "db ")
db_dbf=${db_db:12:-2}

## Override
#db_dbf="drdugo_sevsam"

echo $db_dbf


mysql < /var/srvctl/20140324010005/$db_dbf.sql

mysql -u root -e "show databases;"

owner=$(echo $db_dbf | cut -f1 -d"_" )

echo $owner > /etc/owner

cat /var/www/html/configuration.php | grep '$user '
db_u=$(cat /var/www/html/configuration.php | grep '$user ')
db_usr=${db_u:14:-2}

## Override
#db_usr="drdugo_sevsam"

echo $db_usr

cat /var/www/html/configuration.php | grep "password "
db_p=$(cat /var/www/html/configuration.php | grep "password ")
db_pwd=${db_p:18:-2}

## Override
#db_pwd="zt7Er34W"

echo $db_pwd

#exit
SQL="GRANT ALL ON *.* TO '$db_usr'@'localhost' IDENTIFIED BY '$db_pwd'; flush privileges;"

echo "(JOOMLA) $SQL"

mysql -u root -e "$SQL"

mkdir /log

sed_file /var/www/html/configuration.php "log_path = '" "log_path = '/log'; // '"
sed_file /var/www/html/configuration.php "tmp_path = '" "tmp_path = '/tmp'; // '"
chmod 644 /var/www/html/configuration.php

fi ## joomla


## save these params
conf=/etc/mysqluser.conf
echo 'dbf:'$db_dbf > $conf
echo 'usr:'$db_usr >> $conf
echo 'pwd:'$db_pwd >> $conf


cf=/etc/httpd/conf.d/$(hostname).conf

echo '## srvctl generated' >> $cf
echo '<Directory /var/www/html>' >> $cf

cat /var/www/html/.htaccess >> $cf

echo '' >> $cf
echo '</Directory>' >> $cf
echo '' >> $cf

systemctl restart httpd.service

fi ## config-

if [ "$CMD" == "prefix" ] && $onVE
then
echo prefix-wordpress URI

ln -s /var/www/html /var/www/html/$2

cf=/etc/httpd/conf.d/$(hostname).conf

echo '## srvctl generated' >> $cf
echo '<Directory /var/www/html>' >> $cf
echo ' <IfModule mod_rewrite.c>' >> $cf
echo '  RewriteEngine On' >> $cf
echo '  RewriteBase /'$2'/' >> $cf
echo '  RewriteCond %{REQUEST_FILENAME} !-f' >> $cf
echo '  RewriteCond %{REQUEST_FILENAME} !-d' >> $cf
echo '  RewriteRule . /index.php [L]' >> $cf
echo ' </IfModule>' >> $cf
echo '</Directory>' >> $cf
echo '' >> $cf

systemctl restart httpd.service

fi ## prefix wordpress URI

# instead of /usr/bin/mysql_secure_installation
## .. and setup mysqldump.conf

if [ "$CMD" == "add-db" ] && $onVE
then

## Get $password
get_password

argument db_name
db_usr=$db_name 
#$(echo $db_name | cut -f1 -d"_" )
db_pwd=$password

SQL="CREATE DATABASE $db_name"
echo $SQL
mysql -u root -e "$SQL"


SQL="GRANT ALL ON *.* TO '$db_usr'@'localhost' IDENTIFIED BY '$db_pwd'; flush privileges;"
echo $SQL
mysql -u root -e "$SQL"

## save these params
conf=/etc/mysqluser.conf
echo 'dbf:'$db_name > $conf
echo 'usr:'$db_usr >> $conf
echo 'pwd:'$db_pwd >> $conf



fi # add-db

if [ "$CMD" == "secure" ] && $onVE
then


get_password


log "Set database root password to: "$password

#mysql -u root -e "DELETE FROM mysql.user WHERE User='';"
#mysql -u root -e "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');"
#mysql -u root -e "DROP DATABASE test;"

SQL="UPDATE mysql.user SET Password=PASSWORD('$password') WHERE User='root'; flush privileges;"
mysql -u root -e "$SQL"
echo "$SQL"


## set up backup params
conf=/etc/mysqldump.conf
echo '[client]' > $conf
echo 'user=root' >> $conf
echo 'password='$password >> $conf


fi ## secure

if [ "$CMD" == "reset-db-root" ] && $onVE
then



test=$(mysql --defaults-file=/etc/mysqldump.conf -e "show databases" | grep Database)

if [ "$test" == "Database" ] 
then
echo OK
exit
else
echo "Could not enter mysql!"
fi

systemctl stop mysqld.service

sleep 1

#systemctl status mysqld.service

mysqld_safe --skip-grant-tables &

sleep 10

test=$(mysql --defaults-file=/etc/mysqldump.conf -e "show databases" | grep Database)
if [ "$test" == "Database" ] 
then
echo OK

else
echo "Could not re-enter mysql!"
exit
fi


## generate password on array based variable
declare -a arr=("Ba" "Be" "Bi" "Bo" "Bu" "Ca" "Ce" "Ci" "Co" "Cu" "Da" "De" "Di" "Do" "Du" "Fa" "Fe" "Fi" "Fo" "Fu" "Ga" "Ge" "Gi" "Go" "Gu" "Ha" "He" "Hi" "Ho" "Hu" "Ja" "Je" "Ji" "Jo" "Ju" "Ka" "Ke" "Ki" "Ko" "Ku" "La" "Le" "Li" "Lo" "Lu" "Ma" "Me" "Mi" "Mo" "Mu" "Na" "Ne" "Ni" "No" "Nu" "Pa" "Pe" "Pi" "Po" "Pu" "Ra" "Re" "Ri" "Ro" "Ru" "Sa" "Se" "Si" "So" "Su" "Ta" "Te" "Ti" "To" "Tu" "Va" "Ve" "Vi" "Vo" "Vu" "Za" "Ze" "Zi" "Zo" "Zu")
l=${#arr[@]}
pw=${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}


log "Set database root password to: "$pw

#mysql -u root -e "DELETE FROM mysql.user WHERE User='';"
#mysql -u root -e "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');"
#mysql -u root -e "DROP DATABASE test;"

SQL="UPDATE mysql.user SET Password=PASSWORD('$pw') WHERE User='root'; flush privileges;"
mysql -u root -e "$SQL"
echo mysql -u root -e "$SQL"


## set up backup params
conf=/etc/mysqldump.conf
echo '[client]' > $conf
echo 'user=root' >> $conf
echo 'password='$pw >> $conf




reboot

fi ## reset-db-root

if [ "$CMD" == "mailconf" ] && $onVE
then

echo '@'$(hostname)' root' > /etc/postfix/virtual
postmap /etc/postfix/virtual

echo '# srvctl setup - D250 Laboratories
## Listen on ..
inet_interfaces = all

## Catch all maildefined in ..
virtual_alias_maps = hash:/etc/postfix/virtual

## And send it to ..
home_mailbox = Maildir/
' >> /etc/postfix/main.cf

systemctl restart postfix.service
systemctl status postfix.service

fi ## mailconf

if [ "$CMD" == "backup" ] && $onVE
then

log "Creating backup of Mysql/Mariadb databases."

old_backup=$(ls -d /root/backup/*)

BACKUP_POINT="/root/backup/"$(date +%Y_%m_%d__%H_%M_%S)
mkdir -p $BACKUP_POINT

## All Databases into a single file?
# mysqldump --defaults-file=/etc/mysqldump.conf --all-databases >$BACKUP_POINT/all-databases.sql

succ=1
## create backup for each database
for i in `echo "show databases" | mysql --defaults-file=/etc/mysqldump.conf | grep -v Database`; do 
    if [ "$i" != "information_schema" ] && [ "$i" != "performance_schema" ] 
    then 
    mysqldump --defaults-file=/etc/mysqldump.conf --databases $i > $BACKUP_POINT/$i.sql
    if [ "$?" -eq 0 ]
     then
         echo "OK:   "$i
        else
         echo "ERROR "$i
         echo $err
         succ=0
        fi
    fi
done

if [ $succ -gt 0 ]
then
    echo 'All databases have a backup in '$BACKUP_POINT

    if [ "$2" == "clean" ]
    then
     rm -fr $old_backup
    fi
fi

fi ## backup db


if [ "$CMD" == "adduser" ] && $onVE
then

 if [ -z "$2" ]
  then
    echo "No username argument supplied"
    exit 11
 fi


declare -a arr=("Ba" "Be" "Bi" "Bo" "Bu" "Ca" "Ce" "Ci" "Co" "Cu" "Da" "De" "Di" "Do" "Du" "Fa" "Fe" "Fi" "Fo" "Fu" "Ga" "Ge" "Gi" "Go" "Gu" "Ha" "He" "Hi" "Ho" "Hu" "Ja" "Je" "Ji" "Jo" "Ju" "Ka" "Ke" "Ki" "Ko" "Ku" "La" "Le" "Li" "Lo" "Lu" "Ma" "Me" "Mi" "Mo" "Mu" "Na" "Ne" "Ni" "No" "Nu" "Pa" "Pe" "Pi" "Po" "Pu" "Ra" "Re" "Ri" "Ro" "Ru" "Sa" "Se" "Si" "So" "Su" "Ta" "Te" "Ti" "To" "Tu" "Va" "Ve" "Vi" "Vo" "Vu" "Za" "Ze" "Zi" "Zo" "Zu")
l=${#arr[@]}
password=${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}${arr[$(( RANDOM % $l ))]}

adduser $2
echo $password | passwd $2 --stdin

echo $password > /home/$2/.password

echo "User: $2 password: $passwordd set on $(hostname)"

fi ## adduser

if [ "$CMD" == "fix-postfix" ] && $onVE
then

sed_file /etc/postfix/main.cf 'virtual_alias_maps' '# virtual_alias_maps'
systemctl restart postfix.service
systemctl status postfix.service

fi

